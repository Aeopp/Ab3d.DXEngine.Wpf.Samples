<?xml version="1.0" encoding="utf-8" ?>
<Samples>

  <Sample Page="Other/IntroductionPage.xaml" IsTitle="True" Title="Ab3d.DXEngine Introduction"/>

  <Sample IsSeparator="True" />
  <Sample Page="PowerToys/PowerToysIntroPage.xaml" IsTitle="True" Title="Basic use with Ab3d.PowerToys"/>
  <Sample Page="PowerToys/AllVisualsSample.xaml" Title="AllVisualsSample" Description=""/>
  <Sample Page="PowerToys/SphereVisual3DSample.xaml" Title="SphereVisual3DSample" Description=""/>
  <Sample Page="PowerToys/TextBlockVisual3DSample.xaml" Title="TextBlockVisual3D Sample" Description=""/>
  <Sample Page="PowerToys/Lines3DSample.xaml" Title="Lines3DSample" Description=""/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEnginePerformance/DXEnginePerformanceIntroPage.xaml" IsTitle="True" Title="Extreme performance"/> <!-- Instancing, 3D lines, point cloud -->
  
  <Sample Page="DXEnginePerformance/InstancedMeshGeometry3DTest.xaml" Title="Instanced MeshGeometry3D" Description="This sample shows how to use \bInstancedMeshGeometryVisual3D\b to render incredible amount of 3D meshes with using hardware instancing. Each instance can be rendered with its own color and its own transformation matrix (defines instance position, scale and rotation). Instancing greatly improves performance because there is very little CPU overhead when rendering objects (only one draw call for all instances).\n\bNOTE:\b This sample is using PresentationType set to DirectXOverlay. This can greatly improve performance of rendering instancing because graphic card can render in the background. With DirectXImage, the CPU needs to wait until graphics card finishes rendering and then can send the rendered image to the WPF composition engine. A drawback of DirectXOverlay is that no WPF object can be drawn over 3D scene."/>
  <Sample Page="DXEnginePerformance/InstanceModelGroupVisual3DTest.xaml" Title="Instanced Model3DGroup" Description="This sample shows how to use \bInstancedModelGroupGeometryVisual3D\b to render many instances of Model3DGroup models."/>
  <Sample Page="DXEnginePerformance/InstancedArrowsSample.xaml" Title="Instanced animated arrows" Description="" />
  <Sample Page="DXEnginePerformance/InstanceWorldMatrixSamples.xaml" Title="Instance World matrix samples" Description="" />
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/PixelRenderingSample.xaml" Title="Pixels rendering" Description=""/>
  <Sample Page="DXEnginePerformance/PixelRenderingOptionsSample.xaml" Title="Pixels rendering options" Description=""/>
  <Sample Page="DXEnginePerformance/OptimizedPointCloud.xaml" Title="Optimized Point cloud" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEnginePerformance/PolyLinesSample.xaml" Title="PolyLines sample" Description="PolyLines sample shows that it is possible to render really many lines with hardware accelerated 3D line rendering.\nNote that by default DXEngine does not hardware accelerate rendering connected 3D lines (PolyLines and other lines that are connected to each other). This needs to be enabled with setting RenderConnectedLinesAsDisconnected to true. See code for more information."/>
  <Sample Page="DXEnginePerformance/MultiThreadingSample.xaml" Title="Multi-threading" IsNew="True" Description=""/>
  <Sample Page="DXEnginePerformance/PerformanceTest.xaml" Title="Performance Test" Description="Performance test that shows \bFPS in Windows Title\b.\nThis test uses a special rendering mode where DXEngine does not wait until WPF's Render event but starts rendering new frame immediately after one scene was rendered. This means that the scene is rendered as fast as possible.\nThis mode can be used only for performance testing because it significantly affects WPF's responsiveness (user interface is not updated - therefore FPS is rendered in title that gets updated by Windows).\nThe test is also showing how to use PerformanceAnalyzer."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineVisuals/DXEngineVisualsIntroPage.xaml" IsTitle="True" Title="Improved visuals"/> <!-- Shadows, environment mapping, PBR -->

  <Sample Page="PhysicallyBasedRendering/PBRPropertiesSample.xaml" Title="PBR properties" Description=""/>
  <Sample Page="PhysicallyBasedRendering/PBRModelViewer.xaml" Title="PBR model viewer" Description=""/>
  <Sample Page="PhysicallyBasedRendering/PBRRobotModel.xaml" Title="PBR robot model" Description="The version that is part of the standard samples package uses textures that are scaled down to reduce the size of the package. To get full size 4k textures see the 'get 4k textures.txt' file."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/PerPixelRenderingSample.xaml" Title="Per-pixel rendering" Description=""/>
  <Sample Page="DXEngineVisuals/ShadowRenderingSample.xaml" Title="Shadow rendering" Description=""/>
  <Sample Page="DXEngineVisuals/LineDepthBiasSample.xaml" Title="Line depth bias" Description="Line depth bias sample shows how to use depth bias to offset the depth of the lines. This can prevent drawing the 3D line and solid object at the same depth which causes z-fighting (lines appear disconnected because sometimes they are on top of solid object and sometimes they are inside the solid object).\nThe samples on the left show that the correct bias value needs to be defined based on the size of the objects (see comments in code for more info)."/>
  <Sample Page="DXEngineVisuals/SpecialLineRendering.xaml" Title="Special line rendering" Description=""/>
  <Sample Page="DXEngineVisuals/LinesWithPatternSample.xaml" Title="Lines with pattern" Description="This sample shows how to render lines with patterns.\r\n\bLinePattern\b is an int value that defines the 16 bit int value that defines the line pattern - if bit is 1 then line is drawn, when 0 line is not drawn. Note that the lowest bit is rendered first so the patten value needs to be read from right to left. For example, line with pattern 0xF0F0 will starts with empty part (4 empty bits) and then 4 full parts will be rendered.\r\n\bLinePatternScale\b is a float value that sets the pattern scale factor. Value 1 does not scale the pattern. Values bigger then 1 increase the pattern length; values smaller then 1 decrease the pattern length (making it more dense).\r\n\bLinePatternOffset\b is a float value that sets a pattern offset. This value is usually between 0 and 1 - 0 value means no offset, 1 means offset for the whole patter which is the same as no offset. Value 0.1 means that the line will begin with the pattern advanced by 10%, 1/16 means that the pattern is offset by one bit.\r\n\r\n\bLimitations:\b\r\nLine pattern is not supported on polylines, other connected lines and lines with arrows. To render line patterns on polylines, you will need to convert them to MultiLineVisual3D or other disconnected line type."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/SupersamplingSample.xaml" Title="Supersampling" Description=""/>
  <Sample Page="DXEngineVisuals/EnvironmentReflectionsTest.xaml" Title="Environment Reflections" Description="This sample shows how to show environmental map with various reflection factors. The teapots use the following reflection factors:\nFront left Teapot: reflectionFactor = 1.0f\nFront right Teapot: reflectionFactor = 0.5f\nBack left Teapot: reflectionFactor = new SharpDX.Color3(0.5f, 0.5f, 1.0f)\nBack right Teapot: reflectionFactor = 0.0f"/>
  <Sample Page="DXEngineVisuals/ReflectionMapSample.xaml" Title="Reflection Map" Description="This sample shows how to use reflection map to specify the reflection level on per-pixel level.\nThe ReflectionTexture specifies the reflection factors - white areas are fully reflective, dark gray areas have almost no reflectivity and mostly show the color from diffuse texture that is shown below.\n\nTo create reflection maps you will need to have a texture that is created with unwrapping the 3D model to the texture (this will map the texture coordinates from the texture to the 3D model)"/>
  <Sample Page="DXEngineVisuals/NormalMappingSample.xaml" Title="Normal mapping" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/VertexColorRenderingSample.xaml" Title="VertexColor rendering" Description="This sample shows how to use VertexColorMaterial to render 3D model with specifying different color for each vertex.\nUser can specify custom beam position with moving mouse cursor over the 3D model and holding left mouse button down."/>
  <Sample Page="DXEngineVisuals/LandscapeGeneratorSample.xaml" Title="Landscape generator" Description="This sample demonstrates how the Diamond Square algorithm iteratively generates natural looking landscapes.\nThe height map is rendered with using a \bspecial DXEngine's VertexColorMaterial\b that can render 3D model with specifying different color for each vertex of the model."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineVisuals/PostProcessingTest.xaml" Title="Post-processing test" IsUpdated="True" UpdatedInfo="Added Edge detection filer and controls to change post processes settings." Description="This sample show how to add post-processing effects to the rendered scene.\nWhen checked the post processes are executed in the order as their CheckBoxes are listed. To change the order of post processes, change the code in code-behind."/>
  <Sample Page="DXEngineVisuals/StereoscopicRendering.xaml" Title="Stereoscopic Rendering" Description=""/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineHitTesting/DXEngineHitTestingIntroPage.xaml" IsTitle="True" Title="Ab3d.DXEngine hit testing"/>
  <Sample Page="DXEngineHitTesting/HitTestingSample.xaml" Title="DXEngine Hit Testing" Description="This sample shows how to use hit testing that is part of Ab3d.DXEngine library.\nWhen using the \bGetClosestHitObject\b method, you get the closest hit object.\nWhen using the \bGetAllHitObjects\b you get a list of all hit results (multiple hit results per one object are possible).\n\nThis sample creates a ray from the center of the 3D scene (marked with blue circle) and then executes the specified hit test method. The ray is used to show a green 3D line. All hit positions on the way are marked with red crosses."/>
  <Sample Page="DXEngineHitTesting/DXEventManager3DWrapperSample.xaml" Title="DXEventManager3DWrapper" Description="This samples shows how to wrap the standard EventManager3D from Ab3d.PowerToys library with a DXEventManager3DWrapper. This means that from the outside the class can be still used as EventManager3D but internally it uses hit testing from DXEngine."/>
  <Sample Page="DXEngineHitTesting/DXEventManager3DSample.xaml" Title="DXEventManager3D" Description="DXEventManager3D sample shows how to use \bDXEventsManager3D\b that is part of the DXEngine \binstead of EventsManager3D from Ab3d.PowerToys library\b.\nAn advantage of DXEventsManager3D is that it is much faster because it uses hit testing that is part of Ab3d.DXEngine. Also, it can be used to hit test SceneNode objects that are not created from WPF objects (for example MeshSceneNode objects)."/>
  <Sample Page="DXEngineHitTesting/OctTreeSample.xaml" Title="OctTree sample" Description="OctTree is a data structure that organizes the triangles in 3D space into multiple levels of OctTreeNode objects so that the search of a triangle or a check for triangle ray intersection is very efficient. Each OctTreeNodes divide its space into 8 child OctTreeNodes.\n\nOctTrees are used in DXEngine for very efficient hit testing of complex MeshGeometry3D objects\nFor example, when a standard hit testing is used on a 3D mesh, then the ray needs to be tested for intersection with each triangle in the mesh. Because meshes can have many triangles this can take a lot of time. When OctTree are used, then first the OctTree nodes that intersect the ray are found and then only the triangles in those nodes are checked for intersection with the ray. This massively decreases the number of required intersection tests."/>
  <Sample Page="DXEngineHitTesting/InstancedObjectsHitTesting.xaml" Title="Instanced hit testing" Description="This sample shows hit testing on instanced objects.\nTo make WPF hit testing (used by EventsManager3D) work, you need to set IsWpfHitTestVisible property to true. The code also shows how to get the index of the selected instance."/>

  <Sample IsSeparator="True" />

  <Sample Page="PowerToysOther/PowerToysOtherIntroPage.xaml" IsTitle="True" Title="Other Ab3d.PowerToys samples"/>
  <Sample Page="PowerToysOther/ContentVisual3DSample.xaml" Title="ContentVisual3D sample" Description="\bContentVisual3D\b class can be used to show a GeometryModel3D or a Model3DGroup that is specified to its Content property. The class is very similar to the standard WPF's ModelVisual3D class. A difference is that ContentVisual3D also supports \bIsVisible\b property. This means that when rendered with Ab3d.DXEngine the processing of IsVisible property can be optimized (DirectX resources stay im memory when object is hidden and can be therefore shown very fast)."/>
  <Sample Page="PowerToysOther/EventManagerDragSample.xaml" Title="EventManagerDragSample" Description="This sample is using standard EventManger3D from Ab3d.PowerToys library. The only difference is that when EventManager3D is used with DXEngine, it is recommended to set its CustomEventsSourceElement property - see comment in code behind."/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/ModelMoverOverlaySample.xaml" Title="ModelMover Overlay" Description="This sample shows how to use ModelMoverVisual3D in a Viewport3D over the 3D scene shown by Ab3d.DXEngine.\nThis is done with rendering the content models (boxes in this sample) with DXEngine and rendering the overlay Viewport3D (ModelMoverVisual3D) with WPF 3D.\nThe overlay Viewport3D should be rendered by WPF 3D because ModelMoverVisual3D requires mouse event support on UIElement3D objects. This is not supported when UIElement3D objects are rendered with DXEngine."/>
  <Sample Page="PowerToysOther/ModelMoverInsideObjectSample.xaml" Title="ModelMover inside object" Description="The sample shows how to use ModelMoverVisual3D inside Ab3d.DXEngine.\nTo make mouse events work with ModelMoverVisual3D, the ModelMoverVisual3D must use EventManager3D for events processing. See comments in code for more information."/>
  <Sample Page="PowerToysOther/ModelRotatorSample.xaml" Title="ModelRotatorSample" Description=""/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/MultipleSceneViewSample.xaml" Title="Multiple SceneViews" Description="This sample shows how to render the same 3D objects with multiple DXViewportViews."/>
  <Sample IsSeparator="True" />
  <Sample Page="PowerToysOther/VisualBrushTest.xaml" Title="VisualBrush Test" Description="\bSmall and Big rectangles\b show how to specify different sizes for rendered bitmaps. This is done in code behind with using SetDXAttribute extension method.\n\n\bThree rectangles with green border\b show how to update the material with VisualBrush. The first rectangle does not get updated when VisualBrush is changed. The second rectangle is updated with calling Refresh method on the DXEngine's material that is used to show the WPF's Material. The third rectangle is updated with resetting the Visual property of the VisualBrush (setting the property to null and then back to its previous value). This way DXEngine can get a change notification and it can update the texture.\n\n\bRectangle with orange border\b shows how to dynamically set the size of rendered bitmap based on the size of rendered rectangle on the screen. Move the camera around and zoom with the camera to change the size of the rendered bitmap."/>
  <Sample Page="PowerToysOther/Viewport2DVisual3DTest.xaml" Title="Viewport2DVisual3D Test" Description="This sample shows that mouse and other events on Viewport2DVisual3D are not supported when rendered with Ab3d.DXEngine. The reason for this is that when rendering with Ab3d.DXEngine the Viewport3D is not shown from WPF's perspective and therefore the Viewport2DVisual3D is not getting mouse and other events. Also changes to Viewport2DVisual3D properties are not shown after it was already rendered. If you need Viewport2DVisual3D, then do not use DXEngine and use WPF rendering. To render static WPF controls inside DXEngine use VisualBrush or TextBlockVisual3D (see VisualBrush Test)."/>


  <Sample IsSeparator="True" />

  <Sample Page="DXEngineOther/DXEngineOtherIntroPage.xaml" IsTitle="True" Title="Other Ab3d.DXEngine samples"/>
  
  <Sample Page="DXEngineOther/ManyLightsTest.xaml" Title="Many lights test" Description="This sample shows that DXEngine can render scene with many lights. This is achieved with rendering the scene with multiple passes. But this can also have some limitations - read the comments in the ManyLightsTest.xaml.cs file for more information."/>
  <Sample Page="DXEngineOther/DDSTextureLoading.xaml" Title="DDS texture loading" Description="See code behind for more information on DDS files."/>
  <Sample Page="DXEngineOther/FrustumCullingSample.xaml" Title="Frustum culling" Description=""/>
  <Sample Page="DXEngineOther/RenderToBitmap.xaml" Title="RenderToBitmap" Description="This sample show how to render 3D scene to bitmap without showing the 3D scene"/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineOther/BackgroundObjectsCreation.xaml" Title="Background objects creation" Description="This sample shows how to create 3D objects on the background thread (prevents locking the UI thread while the objects are created)"/>
  <Sample Page="DXEngineOther/BackgroundRenderingSample.xaml" Title="Background Rendering" Description="The sample shows how to create and render the 3D scene on the background thread. This allows rendering very complex scenes without slowing down the processing on the main UI thread. Hover over controls to see ToolTip and see code comments for more details."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineOther/StandardXaml.xaml" Title="Standard XAML and C#" Description="The template sample can be used to get the simple XAML and C# code that can be used as a starting point for your application that use Ab3d.DXEngine and Ab3d.PowerToys.\n\nOther samples in this project use more complex handling of DirectX graphic settings. This allows using the graphics settings set by the user of the application. It also allows overwriting the user settings by using application settings (for example when hardware rendering cannot be initialized because of a broken driver, the application settings can be set to use software rendering or WPF 3D rendering). This template samples is much more simple and provide only a few commented code snippets to specify graphic settings."/>

  <Sample IsSeparator="True" />

  <Sample Page="DXEngineAdvanced/DXEngineAdvancedIntroPage.xaml" IsTitle="True" Title="Advanced Ab3d.DXEngine usage"/> <!-- Low level usage -->
  <Sample Page="DXEngineAdvanced/CustomRenderingStep1.xaml" Title="Custom rendering step 1" Description="This sample shows how executed custom SharpDX rendering code (standard SharpDX &quot;Hello world&quot; sample) inside DXEngine. This allows mixing WPF controls with the 3D scene rendered with SharpDX code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep2.xaml" Title="Custom rendering step 2" Description="This sample shows how to use \bMouseCameraController\b from Ab3d.PowerToys to control camera of the 3D objects rendered with custom SharpDX rendering code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep3.xaml" Title="Custom rendering step 3" Description="This sample shows how to create a new \bCustomActionRenderingStep\b to execute custom SharpDX rendering code. This allows mixing standard DXEngine (WPF 3D) objects and objects rendered with SharpDX code.\nSee comments in code behind for more details."/>
  <Sample Page="DXEngineAdvanced/CustomRenderingStep4.xaml" Title="Custom rendering step 4" Description="This sample shows how to use \bCustomRenderableNode\b to executed custom SharpDX rendering code. See comments in code behind for more details."/>
  <Sample IsSeparator="True" />
  <Sample Page="DXEngineAdvanced/ManuallyCreatedSceneNodes.xaml" Title="Manually created SceneNodes" Description="This sample shows how to manually create SceneNodes and what are benefits of doing that (see code behind for more info).\n- \bBlue pyramid\b is created with standard Ab3d.PowerToys's \bPyramidVisual3D\b.\n- \bGreen pyramid\b is created with using \bGeometryMesh\b and \bMeshObjectNode\b.\n- \bRed, orange and yellow pyramids\b are created with using \bSimpleMes&lt;T&gt;\bh and \bMeshObjectNode\b. (T is PositionNormalTexture struct for red, float for orange and byte for yellow pyramid)\n- \bGray dragon\b is loaded with ReaderObj, then frozen and created with \bWpfOptimizedModel3DGroupNode\b.\n- AB4D logo image demonstrates how to load texture with using \bTextureLoader\b."/>
  <Sample Page="DXEngineAdvanced/ScreenSpaceLineNodeSample.xaml" Title="Creating ScreenSpaceLineNodes" Description="This sample demonstrates how to create and update 3D lines with using low-level ScreenSpaceLineNodes. This can provide performance improvements on initialization and update. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedTubePathSample.xaml" Title="Optimized TubePath" Description="This sample provides alternative ways to show many tube path objects. See code comments for more info."/>
  <Sample Page="DXEngineAdvanced/OptimizedMeshMorphing.xaml" Title="Optimized Mesh morphing" Description=""/>
  <Sample Page="DXEngineAdvanced/CustomShaderMaterialSample.xaml" Title="Custom Shader Material" Description="This sample shows how to use custom shader to color the models based on direction of the triangle normal vector. This is done by creating a custom MeshNormalEffect and MeshNormalMaterial.\n\nThe first line of bunnies show models rendered with MeshNormalMaterial and with different ColorMask applied. The left bunny in the second line is rendered with standard WPF material. The other bunny in the second row is rendered with standard WPF material but with overridden effect so that MeshNormalEffect is used."/>
  <Sample Page="DXEngineAdvanced/CustomFogShaderEffectSample.xaml" Title="Custom fog shader effect" Description="This sample shows how to use custom shader that was designed in Ab3d.DirectX.ShaderFactory project (open and start the project to see a step by step guide about how the shader hlsl code was created).\nThe used FogShader.hlsl shader file is located in the Resources/Shaders/ folder. You can change the shader and recompile it with starting the CompileFogShader.bat. Note that if you will change the constant buffers, you also need to change the FogEffect.cs file."/>
  <Sample Page="DXEngineAdvanced/AdvancedInstanceRendering.xaml" Title="Advanced instance rendering" IsNew="True" Description="This sample creates 3 InstancedMeshGeometry3DNode objects. The first one is used to create the DirectX instance buffer. This instance buffer is then reused by the other 2 InstancedMeshGeometry3DNode objects. Each InstancedMeshGeometry3DNode object renders different part of the instances. This is defined by setting StartInstanceIndex and InstancesCount properties. The sample also shows how to override the color from instances data and render all the instances by some other color."/>
  <Sample Page="DXEngineAdvanced/OutlinesSample.xaml" Title="Object outlines" IsNew="True" Description=""/>
  <Sample Page="DXEngineAdvanced/OptimizedHeightMapGeneration.xaml" Title="Optimized Height Map generation" Description="This sample shows how to generate height maps with direct vertex and index buffer generation. This greatly improves initialization time and reduce memory consumption."/>
  <Sample Page="DXEngineAdvanced/SubMeshesSample.xaml" Title="Using SubMeshes" Description="This sample shows how to create one vertex buffer and one index buffer for many mesh geometries and how it is possible to use SubMeshes to specify different materials for different for parts of this combined mesh. It also shows a very efficient way of changing materials with SumMeshes. See comments in code behind for more info."/>
  <Sample Page="DXEngineAdvanced/ObjectSelectionWithSubMeshes.xaml" Title="Selection with SubMeshes" Description="This sample shows how to efficiently use SubMeshes to show selected object with a different color. This is done with using 3 SubMeshes and changing the StartIndexLocation and IndexCount properties of SubMeshes to define with part of the mesh is shown with selection color."/>
  <Sample Page="DXEngineAdvanced/ShadedPointCloudSample.xaml" Title="ShadedPointCloud sample" Description="Shaded point cloud sample shows how to provide your own implementation of pixels rendering - this time with providing a shader that can shade each pixel with providing a normal for each pixel."/>

  <Sample IsSeparator="True" />
  <Sample Page="Other/WinFormsSample.xaml" IsTitle="True" Title="WinForms samples" Description=""/>
  <Sample Page="Other/ShaderFactoryInfo.xaml" IsTitle="True" Title="ShaderFactory solution" Description=""/>
  <Sample Page="Other/OculusVRSample.xaml" IsTitle="True" Title="Oculus VR support"/>

  <Sample IsSeparator="True" />
  <Sample Page="Other/Ab3dPowerToysSample.xaml" IsTitle="True" Title="Ab3d.PowerToys sample project"/>

</Samples>